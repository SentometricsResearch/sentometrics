% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sentomodel.R
\name{sento_model}
\alias{sento_model}
\title{Optimized and automated sparse regression}
\usage{
sento_model(sentomeasures, y, x = NULL, ctr)
}
\arguments{
\item{sentomeasures}{a \code{sentomeasures} object. There should be at least two explanatory variables including the ones
provided through the \code{x} argument.}

\item{y}{a one-column \code{data.frame} or a \code{numeric} vector capturing the dependent (response) variable. In case of
a logistic regression, the response variable is either a \code{factor} or a \code{matrix} with the factors represented by
the columns as binary indicators, with the last factor level or column as the reference class. No \code{NA} values are
allowed.}

\item{x}{a named \code{data.frame} with other explanatory variables, by default set to \code{NULL}.}

\item{ctr}{output from a \code{ctr_model()} call.}
}
\value{
If \code{ctr$do.iter == FALSE}, a \code{sentomodel} object which is a list containing:
\item{reg}{optimized regression, i.e. a model-specific \code{glmnet} object.}
\item{sentomeasures}{the input \code{sentomeasures} object.}
\item{alpha}{optimized calibrated alpha.}
\item{lambda}{optimized calibrated lambda.}
\item{trained}{output from \code{caret::train} call (if \code{ctr$type ==} "\code{cv}").}
\item{ic}{a \code{list} composed of two elements: the information criterion used in the calibration under
\code{"criterion"}, and a vector of all minimum information criterion values for each value in \code{alphas}
under \code{"opts"} (if \code{ctr$type !=} "\code{cv}").}

If \code{ctr$do.iter == TRUE}, a list containing:
\item{regs}{optimized regressions, i.e. separate \code{sentomodel} objects as above, as a \code{list} with as names the
dates from the perspective of the sentiment measures at which predictions for performance measurement are carried out.}
\item{alphas}{optimized calibrated alphas.}
\item{lambdas}{optimized calibrated lambdas.}
\item{performance}{a \code{data.frame} with performance-related measures, being "\code{RMSFE}" (root mean squared
forecasting error), "\code{MAD}" (mean absolute deviation), "\code{MAPE}" (mean absolute percentage error),
"\code{DA}" (directional accuracy), "\code{accuracy}" (proportion of correctly predicted classes in case of a logistic
regression), and each's respective individual values in the sample. Only the relevant performance statistics are given
depending on the type of regression. Dates are similarly as with the \code{"regs"} output element from the perspective
of the sentiment measures.}
}
\description{
Linear or nonlinear penalized regression of a dependent variable on the wide number of sentiment measures and
potentially other explanatory variables. Either performs a regression given the provided variables at once, or computes
regressions sequentially for a given sample size over a longer time horizon, with associated forecasting performance
metrics. Independent variables are normalized in the regression process, but coefficients are returned in their original
space.
}
\examples{
# construct a sentomeasures object to start with
data("useconomynews")
useconomynews <- useconomynews[date >= "1988-01-01", ]
corpus <- sento_corpus(corpusdf = useconomynews)
l <- setup_lexicons(lexicons[c("LM_eng", "HENRY_eng")], valence[["valence_eng"]])
ctr <- ctr_agg(howWithin = "tf-idf", howDocs = "proportional",
               howTime = c("equal_weight", "linear", "almon"),
               by = "month", lag = 3, ordersAlm = 1:3,
               do.inverseAlm = TRUE, do.normalizeAlm = TRUE)
sentomeasures <- sento_measures(corpus, l, ctr)

# prepare y and other x variables
data("sp500")
y <- sp500$return # convert to numeric vector
sentomeasures <- fill_measures(sentomeasures)
length(y) == nrow(sentomeasures$measures) # TRUE
x <- data.frame(runif(length(y)), rnorm(length(y))) # two other (random) x variables
colnames(x) <- c("x1", "x2")

# a list with models based on the three implemented information criteria
out1 <- list()
for (ic in c("BIC", "AIC", "Cp")) {
ctrIC <- ctr_model(model = "lm", type = ic, do.iter = FALSE, h = 0)
out1[[ic]] <- sento_model(sentomeasures, y, x = x, ctr = ctrIC)
}

# a (very) short iterative analysis of cross-validation based models
ctrCV <- ctr_model(model = "lm", type = "cv", do.iter = TRUE, h = 0, trainWindow = 250,
                   testWindow = 20, oos = 0, nSample = 320, do.progress = TRUE)
out2 <- sento_model(sentomeasures, y, x = x, ctr = ctrCV)

# a similar iterative analysis of cross-validation based models but for a binomial target
yb <- sp500$up
ctrCV <- ctr_model(model = "binomial", type = "cv", do.iter = TRUE, trainWindow = 250,
                   h = 0, testWindow = 20, oos = 0, nSample = 320, do.progress = TRUE)
out3 <- sento_model(sentomeasures, yb, x = x, ctr = ctrCV)

# post-analysis (summary, attribution and prediction)
out <- out1[["BIC"]]
summary(out)

attribution <- retrieve_attributions(out)

nx <- ncol(sentomeasures$measures) - 1 + ncol(x) # don't count date column
newx <- runif(nx) * cbind(sentomeasures$measures[, -1], x)[nrow(x), ]
preds <- predict(out, newx = as.matrix(newx), type = "link")

}
\seealso{
\code{\link{ctr_model}}, \code{\link[glmnet]{glmnet}}, \code{\link[caret]{train}}
}
